/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2026 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f4xx.h"

/* Function prototypes */
void PC_PWM_Config(GPIO_TypeDef *GPIO, uint8_t PIN);
void TIM3_Config(void);
void TIM3_DutyCycle(uint32_t count, uint8_t DutyCycle, uint8_t channel);

/* Global variable */
uint8_t Percentage_DutyCycle_Change = 5;

int main(void)
{
    uint32_t PWM_Period = 1000, delay = 0, LC = 0;

    /* Configure PC6 and PC8 for PWM */
    PC_PWM_Config(GPIOC, 6);   // PC6 -> TIM3_CH1
    PC_PWM_Config(GPIOC, 8);   // PC8 -> TIM3_CH3

    /* Configure Timer 3 */
    TIM3_Config();

    /* Enable TIM3 counter */
    TIM3->CR1 |= (1 << 0);

    while (1)
    {
        /* Increase brightness */
        for (LC = 0; LC <= (100 / Percentage_DutyCycle_Change); LC++)
        {
            TIM3_DutyCycle(PWM_Period, LC * Percentage_DutyCycle_Change, 1);
            TIM3_DutyCycle(PWM_Period, LC * Percentage_DutyCycle_Change, 3);

            for (delay = 0; delay < 100000; delay++);
        }

        /* Decrease brightness */
        for (LC = (100 / Percentage_DutyCycle_Change); LC > 0; LC--)
        {
            TIM3_DutyCycle(PWM_Period, LC * Percentage_DutyCycle_Change, 1);
            TIM3_DutyCycle(PWM_Period, LC * Percentage_DutyCycle_Change, 3);

            for (delay = 0; delay < 100000; delay++);
        }
    }
}

/* GPIO Configuration for PC6 & PC8 */
void PC_PWM_Config(GPIO_TypeDef *GPIO, uint8_t PIN)
{
    /* Enable GPIOC clock */
    RCC->AHB1ENR |= (1 << 2);

    /* Set Alternate Function mode */
    GPIO->MODER &= ~(3U << (PIN * 2));
    GPIO->MODER |=  (2U << (PIN * 2));

    /* Select AF2 (TIM3) */
    if (PIN < 8)
    {
        GPIO->AFR[0] &= ~(0xFU << (PIN * 4));
        GPIO->AFR[0] |=  (2U   << (PIN * 4));
    }
    else
    {
        GPIO->AFR[1] &= ~(0xFU << ((PIN - 8) * 4));
        GPIO->AFR[1] |=  (2U   << ((PIN - 8) * 4));
    }
}

/* TIM3 Configuration for PWM */
void TIM3_Config(void)
{
    /* Enable TIM3 clock */
    RCC->APB1ENR |= (1 << 1);

    TIM3->PSC = 0;

    /* PWM mode for CH1 */
    TIM3->CCMR1 |= (1 << 3);        // preload enable
    TIM3->CCMR1 |= (6 << 4);        // PWM mode 1

    /* PWM mode for CH3 */
    TIM3->CCMR2 |= (1 << 3);
    TIM3->CCMR2 |= (6 << 4);

    /* Enable outputs */
    TIM3->CCER |= (1 << 0);   // CH1
    TIM3->CCER |= (1 << 8);   // CH3
}

/* Duty cycle control */
void TIM3_DutyCycle(uint32_t count, uint8_t DutyCycle, uint8_t channel)
{
    TIM3->ARR = 16000000U / count;

    if (channel == 1)
    {
        TIM3->CCR1 = (DutyCycle * TIM3->ARR) / 100;
    }
    else if (channel == 3)
    {
        TIM3->CCR3 = (DutyCycle * TIM3->ARR) / 100;
    }
}
